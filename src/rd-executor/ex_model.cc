#include "ex_local.hh"
using namespace executor;

static constexpr byte const FakeGLAFile[] = {
	0x32, 0x4C, 0x47, 0x41, 0x06, 0x00, 0x00, 0x00, 0x2A, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0x01, 0x00, 0x00, 0x00,
	0x14, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
	0x26, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x4D, 0x6F, 0x64, 0x56, 0x69, 0x65, 0x77, 0x20,
	0x69, 0x6E, 0x74, 0x65, 0x72, 0x6E, 0x61, 0x6C, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74,
	0x00, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
	0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
	0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0xBF, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE, 0x7F,
	0x00, 0x80, 0x00, 0x80, 0x00, 0x80
};

instance::model_registry::model_registry() {
	model_t & mod =  models.emplace_back(make_q3model())->mod;
	strcpy(mod.name, "BAD MODEL");
	mod.type = MOD_BAD;
	mod.index = 0;
}

q3model_ptr instance::model_registry::reg(char const * name, bool server) {
	auto m = lookup.find(name);
	if (m != lookup.end()) return m->second;
	
	q3model_ptr mod = models.emplace_back(make_q3model());
	mod->mod.index = models.size() - 1;
	
	if (!Q_stricmp(name, "*default.gla")) {
		strcpy(mod->mod.name, name);
		mod->buffer.resize(mod->mod.dataSize = sizeof(FakeGLAFile));
		memcpy(mod->buffer.data(), FakeGLAFile, sizeof(FakeGLAFile));
		mod->load();
		assert(mod->mod.type == MOD_MDXA);
		return lookup[name] = mod;
	}
	
	lookup[name] = mod;
	return mod;
}

q3model_ptr instance::model_registry::get(qhandle_t h) {
	if (h < 0 || h >= static_cast<int32_t>(models.size())) return nullptr;
	return models[h];
}

void q3model::load() {
	uint32_t ident = reinterpret_cast<uint32_t *>(buffer.data())[0];
	switch(ident) {
		case MDXA_IDENT: load_mdxa(); break;
		case MDXM_IDENT: /* TODO -- load MDXM */; break;
		case MD3_IDENT: /* TODO -- load MD3 */; break;
		default:
			mod.type = MOD_BAD;
	}
}

void q3model::load_mdxa() {
	mod.type = MOD_MDXA;
}

void q3model::load_mdxm(bool server) {
	mod.type = MOD_MDXM;
}

void q3model::load_md3(int32_t lod) {
	mod.type = MOD_MESH;
}
